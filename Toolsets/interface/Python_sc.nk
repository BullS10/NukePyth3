set cut_paste_input [stack 0]
version 11.2 v5
push $cut_paste_input
NoOp {
name Python_sc
tile_color 0xffe500
note_font_size 20
selected true
xpos -6335
ypos 6618
addUserKnob {20 User}
addUserKnob {26 filter l "set filter"}
addUserKnob {22 Filter2Impulse l "set filter to Impulse" T "for n in nuke.selectedNodes():\n    n\['filter'].setValue(0)" +STARTLINE}
addUserKnob {22 Filter2Cubic l "set filter to Cubic" -STARTLINE T "for n in nuke.selectedNodes():\n    n\['filter'].setValue(1)"}
addUserKnob {26 output l "set output"}
addUserKnob {22 merge_RGB2RGBA l "Merge.output RGB to RGBA" T "for n in nuke.selectedNodes():\n    n\['output'].setValue('rgba')" +STARTLINE}
addUserKnob {22 mergeRGBA2RGB l "Merge.output RGBA to RGB" -STARTLINE T "for n in nuke.selectedNodes():\n    n\['output'].setValue('rgb')"}
addUserKnob {26 Bbox l "set Bbox"}
addUserKnob {22 Bbox2Union l "set Bbox to Union" T "for n in nuke.selectedNodes():\n    n\['bbox'].setValue(0)" +STARTLINE}
addUserKnob {22 Bbox2A l "set Bbox to A" -STARTLINE T "for n in nuke.selectedNodes():\n    n\['bbox'].setValue(2)"}
addUserKnob {22 Bbox2B l "set Bbox to B" -STARTLINE T "for n in nuke.selectedNodes():\n    n\['bbox'].setValue(3)"}
addUserKnob {26 windows}
addUserKnob {22 closewindow l "close all floating windows" T "for n in nuke.allNodes():\n   n.hideControlPanel()" +STARTLINE}
addUserKnob {26 rototext l roto}
addUserKnob {22 bakeRotoToTracker l "bake roto to tracker" T "import nuke.rotopaint as rp, _curvelib as cl, nukescripts, nuke, math, time\n\nclass ShapePanel(nukescripts.PythonPanel):\n    def __init__(self, node):\n        nukescripts.PythonPanel.__init__(self, 'RotoPaint Elements')\n        self.rp_node = node\n        self.frame_range = nuke.String_Knob('frame_range', 'Frame Range', '\{0\}-\{1\}'.format(nuke.root().firstFrame(), nuke.root().lastFrame()))\n        self.type_filter_knob = nuke.Enumeration_Knob('element', 'Element Type', \['Shapes', 'Strokes'])\n        self.element_knob = nuke.Enumeration_Knob('curve', 'Curve', \[])\n        self.cv_knob = nuke.Enumeration_Knob('cv', 'CV', \[])\n        self.cv_knob.clearFlag( nuke.STARTLINE )\n        for k in (self.frame_range, self.type_filter_knob, self.element_knob, self.cv_knob):\n            self.addKnob(k)\n        self.elements = \{\}\n        self.get_elements()\n\n    def parse_layer(self, layer, elements, parents):\n        \"\"\"Return a list of all Shapes or Strokes in a Roto or Rotopaint node's heirarchy, with a list of all parent Layers for each item.\"\"\"\n        for e in layer:\n            if isinstance(e, rp.Shape):\n                elements\['Shapes'].append(\[e, parents])\n            elif isinstance(e, rp.Stroke):\n                elements\['Strokes'].append(\[e, parents])\n            elif isinstance(e, rp.Layer):\n                parents_copy = parents\[:]\n                parents_copy.insert(0, e)\n                elements = self.parse_layer(e, elements, parents_copy)\n        return elements\n\n    def get_elements(self):\n        \"\"\"    Get all Shape Stroke and Layer elements in our Roto/Paint node.\"\"\"\n        self.elements = \{ 'Shapes':\[], 'Strokes':\[] \}\n        self.curves_knob = self.rp_node\['curves']\n        self.root_layer = self.curves_knob.rootLayer\n        self.elements = self.parse_layer(self.root_layer, self.elements, \[self.root_layer])\n\n    def knobChanged(self, knob):\n        \"\"\"    Modify contents of element_knob and cv_knob: if Shapes are selected, element_knob shows shapes.\n            If Strokes are selected, element_knob shows Strokes.\n            And Whatever element_knob is selected, the number of CVs is displayed in cv_knob\"\"\"\n        if knob is self.type_filter_knob or knob.name() == 'showPanel':\n            self.element_knob.setValues( \[x\[0].name for x in self.elements\[self.type_filter_knob.value()]])\n            # Update the element knob also\n            #self.selected_element_and_parents\n        if knob is self.element_knob or knob.name() == 'showPanel':\n            # To get the name value of an enumKnob, you have to do .enumName(int(knob.getValue())): http://forums.thefoundry.co.uk/phpBB2/viewtopic.php?p=15856&sid=a17f123d8eee3f16ded415be6ac478f5\n            selected_element_name = self.element_knob.enumName(int(self.element_knob.getValue()))\n            # Find the shape or stroke object that matches the selected element name\n            for e in self.elements\[self.type_filter_knob.value()]:\n                if e\[0].name == selected_element_name:\n                    # Variable to access element and associated parent layer objects outside of class\n                    self.selected_element_and_parents = e\n                    parentnames = \[p.name for p in e\[1]]\n                    parentnames.reverse()\n                    # toElement() function does not include root in path\n                    parentnames.remove('Root')\n                    element_path = '/'.join(parentnames)\n                else:\n                    continue\n            # element_path_name is the path to the element, eg: 'Layer1/NestedLayer2/Bezier1'\n            element_path_name = element_path+'/'+selected_element_name\n            selected_element = self.curves_knob.toElement( element_path_name )\n            # This list comprehension generates range of numbers matching CV points\n            self.cv_knob.setValues(\[i for i, x in enumerate(selected_element)])\n\n        if knob is self.cv_knob:\n            self.selected_cv = int(self.cv_knob.enumName(int(self.cv_knob.getValue())))\n            # Set frame_range knob to match first and last keyframes on selected CV if Shape (Strokes have no method to get point keyframes)\n            if self.type_filter_knob.value() == 'Shapes':\n                cv_keys = self.selected_element_and_parents\[0]\[self.selected_cv].center.getControlPointKeyTimes()\n                self.frame_range.setValue('\{0\}-\{1\}'.format(int(cv_keys\[0]), int(cv_keys\[-1])))\n            else:\n                self.frame_range.setValue('\{0\}-\{1\}'.format(nuke.root().firstFrame(), nuke.root().lastFrame()))\n        #!TODO - Stroke support is broken, need to initialize cv on start so don't need to change it for it to work\n        # Also if there is only 1 shape or stroke, the element will not get passed down\n\n\ndef TransformPoint(point, frame, item):\n    \"\"\"Transform a point with a layer or object's transform properties, given a point and a frame. Compatible with > Nuke 6.2 only.\"\"\"\n    extramatrix = item.getTransform().evaluate(frame).getMatrix()\n    vector = nuke.math.Vector4(point\[0], point\[1], 1, 1)\n    x = (vector\[0] * extramatrix\[0]) + (vector\[1] * extramatrix\[1]) + extramatrix\[2] + extramatrix\[3]\n    y = (vector\[0] * extramatrix\[4]) + (vector\[1] * extramatrix\[5]) + extramatrix\[6] + extramatrix\[7]\n    z = (vector\[0] * extramatrix\[8]) + (vector\[1] * extramatrix\[9]) + extramatrix\[10] + extramatrix\[11]\n    w = (vector\[0] * extramatrix\[12]) + (vector\[1] * extramatrix\[13]) + extramatrix\[14] + extramatrix\[15]\n    new_point = nuke.math.Vector4(x, y, z, w) / w\n    return new_point\n\n\ndef CVPointToTrack(rp_node, element_type, element, parents, cv, framerange):\n    \"\"\"    Takes a point of an element and \"un-parents\" it from its parent transforms,\n        then generates tracking data for that point.\n    \"\"\"\n    # Add knob to receive cv point track data, create another tab if it doesn't already exist\n    if rp_node.knob('user_tracks') == None:\n        rp_node.addKnob(nuke.Tab_Knob('user_tracks', 'Tracks'))\n    track_knob = nuke.XY_Knob('\{0\}_cv\{1\}'.format(element.name, cv))\n    rp_node.addKnob(track_knob)\n    track_knob.setAnimated()\n    track_knob_anim = \[track_knob.animation(0), track_knob.animation(1)]\n\n    # Create a list of nuke.AnimationKey objects for each unparented cv point value\n    cv_anim = \[\[],\[]]\n    for frame in xrange(framerange\[0], framerange\[1]+1):\n        #??? Would these be better/faster to do with getAnimationCurve?\n        if element_type == 'Shapes':\n            # Get parented position of point on shape\n            cv_pos = \[element\[cv].center.getPosition(frame)\[0], element\[cv].center.getPosition(frame)\[1]]\n        elif element_type == 'Strokes':\n            cv_pos = \[element\[cv].getPosition(frame)\[0], element\[cv].getPosition(frame)\[1]]\n        all_parents = parents\[:]\n        # Include self in parents, in case there are transforms on the object in question\n        all_parents.insert(0, element)\n        #print \[x.name for x in all_parents]\n        # Unparent the cv point from the transforms of all parents\n        unparented_cv_pos = cv_pos\n        for parent in all_parents:\n            unparented_cv_pos = TransformPoint(unparented_cv_pos, frame, parent)\n            #print parent.name, unparented_cv_pos\n        for i in \[0,1]:\n            cv_anim\[i].append(nuke.AnimationKey(frame, unparented_cv_pos\[i]))\n    #print \[cv_anim]\n    for i in \[0,1]:\n        track_knob_anim\[i].addKey(cv_anim\[i])\n\ndef init():\n    rp_node = nuke.selectedNode()\n    p = ShapePanel(rp_node)\n    p.showModalDialog()\n    element_type = p.type_filter_knob.value()\n    element = p.selected_element_and_parents\[0]\n    parents = p.selected_element_and_parents\[1]\n\n    cv = p.selected_cv\n    framerange = map(int, p.frame_range.value().split('-'))\n    print \"starting cgpoitntotrack function with\", element_type, element.name, \[x.name for x in parents], cv, framerange\n    CVPointToTrack(rp_node, element_type, element, parents, cv, framerange)\n\nif __name__==\"__main__\":\n    init()" +STARTLINE}
addUserKnob {22 Roto_retime l "Roto retime" -STARTLINE T "from __future__ import print_function\nimport nuke\nimport nuke.rotopaint as rp\nimport _curvelib as cl\n\ndef unselect():\n    _ = \[n.setSelected(False) for n in nuke.allNodes(recurseGroups=True)]\n\ndef duplicate(node):\n    unselect()\n    node.setSelected(True)\n    nuke.nodeCopy('%clipboard')\n    unselect()\n    new_node = nuke.nodePaste('%clipboard')\n    new_node.setXYpos(node.xpos() + 120, node.ypos())\n    new_node.setInput(0, node.input(0))\n    return new_node\n\n\ndef parse_layer(root_layer, elements, parents):\n    # recursively gather all shapes and strokes in specified roto layer\n    for element in root_layer:\n        if isinstance(element, rp.Shape):\n            print('adding shape element \{0\}'.format(element.name))\n            elements\['Shapes'].append(\[element, parents])\n        elif isinstance(element, rp.Stroke):\n            print('adding Stroke element \{0\}'.format(element.name))\n            elements\['Strokes'].append(\[element, parents])\n        elif isinstance(element, rp.Layer):\n            parent_names = \[l.name for l in parents]\n            parent_names.reverse()\n            print('Getting contents of layer element \{0\}\\nwith parent \{1\}'.format(\n                element.name, '/'.join(parent_names)))\n            parents_copy = parents\[:]\n            parents_copy.insert(0, element)\n            elements = parse_layer(element, elements, parents_copy)\n    return elements\n\n\ndef get_elements(node):\n    # Get all shape stroke and layer elements from specified Roto, RotoPaint, or SplineWarp node\n    supported_classes = \['Roto', 'RotoPaint', 'SplineWarp3']\n    if node.Class() in supported_classes:\n        elements = \{'Shapes': \[], 'Strokes': \[]\}\n        root_layer = node\['curves'].rootLayer\n        elements = parse_layer(root_layer, elements, \[root_layer])\n        return elements\n\n\ndef start(nodes=nuke.selectedNodes()):\n    # Retime all shapes in specified roto rotopaint and splinewarp nodes.\n    # OpenSplines and Strokes are not supported.\n    # For documentation check print help(_curvelib)\n\n    for node in nodes:\n        # Create copy of node to retime\n        node = duplicate(node)\n\n        elements = get_elements(node)\n        shapes = \[e\[0] for e in elements\['Shapes']]\n        # strokes = \[e\[0] for e in elements\['Strokes']]\n        \n        # Add frame_lookup knob. This is where the user puts their retime curve.\n        if 'frame_lookup' not in node.knobs():\n            node.addKnob(nuke.Tab_Knob('Retime', 'Retime'))\n            node.addKnob(nuke.Double_Knob('frame_lookup', 'frame_lookup'))\n\n        for shape in shapes:\n            print('Retiming \{0\}'.format(shape.name))\n            # Set retime expression on each point in the shape for\n            # center, left and right tangents, for main curve and feather curve\n            for point in shape:\n                # Get AnimCurve objects for the point\n                # Note: OpenSpline objects are not supported. \n                # Seems like the width property of the spline is not supported in the Nuke Python API\n                point_data = \[point.center, point.featherCenter, point.featherLeftTangent, point.featherRightTangent, point.leftTangent, point.rightTangent]\n                animcurves = \[(d.getPositionAnimCurve(0), d.getPositionAnimCurve(1)) for d in point_data]\n                \n                # Set retime expression on each animcurve\n                for animcurve_tuple in animcurves:\n                    for animcurve in animcurve_tuple:\n                        animcurve.useExpression = True\n                        animcurve.expressionString = 'curve(frame_lookup)'\n\n            # Find all animated attributes of the shape and add retime expression to those as well.\n            attr_names = \['a', 'ao', 'bm', 'b', 'bo', 'bs', 'bsp', 'bt', 'bu', 'dh', 'ds', 'dt', 'ep1', 'ep2', 'ep3', 'ff', 'fo', 'ft', 'fx', 'fy', 'g', 'go', 'h', 'inv', 'ltm', 'ltn', 'ltt', 'mb', 'mbo', 'mbs', 'mbso', 'mbsot', 'nv', 'opc', 'pt', 'r', 'ro', 'src', 'spx', 'spy', 'sr', 'ssx', 'ssy', 'sso', 'sskx', 'ssky', 'sto', 'stot', 'str', 'stx', 'sty', 't', 'view', 'vis', 'we', 'ws']\n            \n            shape_attrs = shape.getAttributes()\n            for attr_name in attr_names:\n                # Check if there are keyframes on this attr. If so we add an expression to retime\n                if shape_attrs.getNumberOfKeys(attr_name) > 0:\n                    animcurve = shape_attrs.getCurve(attr_name)\n                    animcurve.useExpression = True\n                    animcurve.expressionString = 'curve(frame_lookup)'\n\n        node\['curves'].changed()\n\n\n\nif __name__=='__main__':\n    start()"}
addUserKnob {20 endGroup n -1}
}
